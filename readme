Logfind

Logfind provides similar functionality to grep -F (aka fgrep) and sed(1) programs.
The user can specify mulitple search patterns with actions to be performed
in each match.

SYNTAX
    The basic syntax is pretty simple.
    /pattern/ {
        action
          .
          .
    }

    Each time the pattern matches a line, the listed actions are executed
    in the order listed.

SPECIAL PATTERNS
    There are a number of special patterns defined

    /!program-start!/ {
        # This pattern will get invoked at the start of the program
    }

    /!program-end!/ {
        # This pattern will get invoked at the end of the program
    }

    /!file-start!/ {
        # This pattern will get invoked at the start of processing a file
    }
    /!file-end!/ {
        # This pattern will get invoked at the end of processing a file
    }

    /!user-defined!/
        This pattern can be called by the 'call' action. It this is useful
        for reusing a pattern and a set of actions. The string "user-defined"
        is a place holder for the name you want to call it.

ACTIONS
    The following actions are supported for each pattern match. Additional
    actions can be easily defined and implemented for customizing.

    print
        Print the current matched line to the current output.

    print "fmt"
        Print the matching line to the current output.
        "fmt" is a quoted string containing the text to be printed. The
        following format variables are defined:
            ${lineno}   Line number of the match
            ${offset}   File offset of the line where the match was found
            ${match}    Print the matched text.
            ${match+n}  Print match text + n addional characters
            ${match/c}  Print match text until the given delimiter 'c' is seen
            ${line}     Print the whole line
            ${line:m,}  Print the line, from m to end of line. If m < 0, the starting
                        position is m characters from the end.
            ${line:,n}  Print the line, from begining of line to n. If n < 0, the 
                        ending position is n characters from the end of the line.
            ${line:m,n} Print the line columns m through n. Negative numbers apply as above.
            ${time}     If the match line contains a timestamp, print it as the number
                        of microseconds. The line's timestamp must be in TTLOG format
            ${filename} Print the current filename

        Note: If a "fmt" is specified, a NL is not automatically added. You must supply
              the \n if you want a new line.

    count "fmt"
        Count the number of matches of the pattern. "fmt" will be printed when the 
        program exits. Format must contain a ${count} specifier to print the count, 
        such as "Number of matches: ${count}\n"

    max-count n [--exit]
        Perform the actions n number of times. If --exit is specified, the program will
        exit when the count is reached.

    file "filename" [--append]
    file --stdout
    file --stderr
        The output of actions following this action will be sent to "filename". It is possible to 
        send output to multiple files, or have each pattern match sent to separate files
        if desired.

    interval "fmt"
        Print the time since the last pattern match. The matched patterns must contain a TTLOG
        timestamp. The output will print the number of days, hours, minutes, seconds, and microseconds.
        "fmt" will be used to print the time. Format must contain a ${time} specifier to 
        print the time, such as "Elapsed time since last message: ${time}\n"

    after n [--fmt "fmt"]
        Print n lines after the match. 
        --fmt: If present, will use the print format. For the purposes of the format, the entire 
               line is considered a match.

    before n [--fmt "fmt"]
        Print n lines before the match.
        --fmt: If present, will use the print format. For the purposes of the format, the entire 
               line is considered a match.

    call name
        Call a user defined pattern name

    exit
        Exit the program

    /pattern/ {
        ...
    }
        Search for a pattern in the currently matched line. Each sub pattern
        can define a set of actions to be executed.

            
PERFORMANCE
    This program uses the aho-corasick algorithim for finding the pattern matches. With an 
    arbitrary number of patterns to search for, it is guaranteed to look at each input byte
    only once, therefore it will run in linear time with the size of the file. The implementation
    also does not break the input into lines but rather the pattern search is run against 
    the entire input, only when a match is found are the bounding line endings located. The
    input is backed by in LRU cache of 1MB pages with read ahead to support the 'before' and 
    'after' actions.

    Each sub-pattern is run using a separate context for the algorithim. Again, running multiple
    pattern searches on a line match will run in linear time.

EXAMPLES
    Simple example show a single search
        /ExecutionReport/ {
            print
        }

    You can search for multiple patterns
        /ExecutionReport/ {
            print
        }

        /OrderCancelReject/ {
            print
        }

    Find the given order id and count them, output goes to
    stdout. For each cxlrpl, print the elapsed time since 
    the prvious cxlrpl and print the line number and line
    to a file.
        /bb77a423-f475-434b-a336-3bd09a32c464/ {
            count "Number of er's: ${count}\n"
            print
            /EXEC_TYPE_REPLACED/ {
                file "cxlrpl.log"
                interval "CxlRpl interval: ${time}\n"
                print "${lineno} ${line}\n"
            }
        }

    Print only the first match
        /ExecutionReport/ {
            max-count 1   
            print
        }

    Separate input into multiple files
        /ExecutionReport/ {
            file "ers.log"
            print
        }

        /OrderCancelReject/ {
            file "ocr.log"
            print
            file --stdout
            count "Number of ocrs: ${count}"   # lets count how many we found to stdout
        }

    Search for an order id, for each trade, 
    print the account id and er.
        /bb77a423-f475-434b-a336-3bd09a32c464/ {
            /EXEC_TYPE_TRADE/ {
                /account_id=/ {
                    # Because er's are printed with space separated field=value
                    # pairs (user_id=1234 account_id=5678 price=1.3...) we print
                    # the starting at the match up to the first space character
                    print "account-id: ${match/ }\n"

                    # print the er
                    print
                }
            }
        }

NOTES
    See https://github.com/morenice/ahocorasick
    for aho-corasick algorithm

    I have not used flex/bison for the parser, but hand coded it. This will prob change in the future
    but as of now, it is rather crude and sensitive to syntax errors and may crash if not correct.


Config sample

/!program-start!/ {
    # This pattern will get invoked at the start of the program
}

/!program-end!/ {
    # This pattern will get invoked at the end of the program
}

/!file-start!/ {
    # This pattern will get invoked at the start of processing a file
}
/!file-end!/ {
    # This pattern will get invoked at the start of processing a file
}
##################################################################
OrderId {
    /ExecutionReport/ {
        print-er
        print
    }
    /OrderCancelReject/ {
        print-ocr
        print
    }
}

bof {
     print "Start search"
}

eof {
    print "Number of trades: $trade\n"
    print "Number of NOS: $nos\n"
}

/S T A R T/ {
    print
}

/S H U T D O W N/ {
    print
}

/Orderserver is ready/ {
    print
}

/9fbe0-345f-7822/ {
    /account_id=/ {
        print "${match/ }"
    }
    /user_id=/ {
        print "${match/ }"
    }
    /exec_type=/ {
        print "${match/ }"
    }
    print "${lineno} ${line:,120}"
}

/LEADER |/ {
    print "The leader is: $line\n"
}

/xxxx-xxx-xxxxx-xxx/ {
    /EXEC_TYPE_TRADE/ {
        $trade = +1
    }
    /EXEC_TYPE_NOS/ {
        $nos += 1
    }
}

/ExecutionReport/ {
    print-timestamp
}
