Logfind

Logfind provides similar functionality to grep -F (aka fgrep) and sed(1) programs.
The user can specify mulitple search patterns with actions to be performed
in each match.

SYNTAX
    The basic syntax is pretty simple.
    /pattern/ {
        action
          .
          .
        }
    }

    Each time the pattern matches a line, the listed actions are executed
    in the order listed.

ACTIONS
    The following actions are supported for each pattern match. Additional
    actions can be easily defined and implemented for customizing.

    print
        Print the current matched line to the current output.

    print "fmt"
        Print the matching line to the current output.
        "fmt" is a quoted string containing the text to be printed. The
        following variables are defined.
            ${lineno}   Line number of the match
            ${offset}   File offset of the line where the match was found
            ${match}    Print the matched text.
            ${match+n}  Print match pattern + n addional chars
            ${match/c}  Print match pattern until the given delimiter 'c' is seen
            ${line}     Print the whole line
            ${line:m,}  Print the line, from m to end of line. If m < 0, the starting
                        position is m characters from the end.
            ${line:,n}  Print the line, from begining of line to n. If n < 0, the 
                        ending position is n characters from the end of the line.
            ${line:m,n} Print the line columns m through n. Negative numbers apply as above.
            ${time}     If the match line contains a timestamp, print it as the number
                        of microseconds. The line's timestamp must be in TTLOG format
            ${filename} Print the current filename

    count "fmt"
        Count the number of matches of the pattern. "fmt" will be printed when the 
        program exits. Format must contain a ${count} specifier to print the count, 
        such as "Number of matches: ${count}\n"

    max-count n [--exit]
        Perform the actions n number of times. If --exit is specified, the program will
        exit when the count is reached.

    file "filename" [--append]
    file --stdout
    file --stderr
        The output of actions following this action will be sent to "filename". It is possible to 
        send output to multiple files, or have each pattern match sent to separate files
        if desired.

    interval "fmt"
        Print the time since the last pattern match. The matched patterns must contain a TTLOG
        timestamp.
        "fmt" will be used to print the time. Format must contain a ${time} specifier to 
        print the time, such as "Number of seconds: ${time}\n"

    after n [--fmt "fmt"]
        Print n lines after the match. 
        --fmt: If present, will use the print format. For the purposes of the format, the entire 
               line is considered a match.

    before n [--fmt "fmt"]
        Print n lines before the match.
        --fmt: If present, will use the print format. For the purposes of the format, the entire 
               line is considered a match.

    exit
        Exit the program

    /pattern/ {
        ...
    }
        Search for a pattern in the currently matched line. Each sub pattern
        can define a set of actions to be executed.

            
PERFORMANCE
    This program uses the aho-corasick algorithim for finding the pattern matches. With an 
    arbitrary number of patterns to search for, it is guaranteed to look at each input byte
    only once, therefore it will run in linear time with the size of the file. The implementation
    also does not break the input into lines but rather the pattern search is run against 
    the entire input, only when a match is found are the bounding line endings located. The
    input is backed by in LRU cache of 1MB pages with read ahead to support the 'before' and 
    'after' actions.

    Each sub-pattern is run using a separate context for the algorithim. Again, running multiple
    pattern searches on a line match will run in linear time.

EXAMPLES
    Simple example show a single search
        /ExecutionReport/ {
            print
        }

    You can search for multiple patterns
        /ExecutionReport/ {
            print
        }

        /OrderCancelReject/ {
            print
        }

    Print only the first match
        /ExecutionReport/ {
            max-count 1   
            print
        }

    Separate input into multiple files
        /ExecutionReport/ {
            file "ers.log"
            print
        }

        /OrderCancelReject/ {
            file "ocr.log"
            print
            file --stdout
            count "Number of ocrs: ${count}"   # lets count how many we found to stdout
        }

NOTES
    See https://github.com/morenice/ahocorasick
    for aho-corasick algorithm

    I have not used flex/bison for the parser, but hand coded it. This will prob change in the future
    but as of now, it is rather crude and sensitive to syntax errors and may crash if not correct.


Config sample

/!begin!/ {
    # This pattern will get invoked at the start of the program
}

/!end!/ {
    # This pattern will get invoked at the end of the program
}

/!user-defined!/ {
    
}

##################################################################
OrderId {
    /ExecutionReport/ {
        print-er
        print
    }
    /OrderCancelReject/ {
        print-ocr
        print
    }
}

bof {
     print "Start search"
}

eof {
    print "Number of trades: $trade\n"
    print "Number of NOS: $nos\n"
}

/S T A R T/ {
    print
}

/S H U T D O W N/ {
    print
}

/Orderserver is ready/ {
    print
}

/9fbe0-345f-7822/ {
    /account_id=/ {
        print "${match/ }"
    }
    /user_id=/ {
        print "${match/ }"
    }
    /exec_type=/ {
        print "${match/ }"
    }
    print "${lineno} ${line:,120}"
}

/LEADER |/ {
    print "The leader is: $line\n"
}

/xxxx-xxx-xxxxx-xxx/ {
    /EXEC_TYPE_TRADE/ {
        $trade = +1
    }
    /EXEC_TYPE_NOS/ {
        $nos += 1
    }
}

/ExecutionReport/ {
    print-timestamp
}
